<!DOCTYPE html>
<html lang="ko">
<head>
<<<<<<< HEAD
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î©îÎ™®Î¶¨ Í≤åÏûÑ</title>
    <style>
@font-face {
    font-family: 'PFStardust';
    src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/PFStardust.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

body.game-background {
    background-image: url('img/background.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-color: #D9D9D9;
    color: #fff;
    font-family: 'PFStardust', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    position: relative;
}

h1 {
    font-size: 2.2em;
    text-shadow: 2px 2px 4px #000;
    margin-bottom: 20px;
    z-index: 2;
}

.menu, .difficulty-menu {
    z-index: 2;
    text-align: center;
    display: flex;
    flex-direction: row;
    align-items: center;
}

.button-group {
    display: flex;
    flex-direction: column;
    margin: 0 60px;
}

.menu button, .difficulty-menu button {
    background-color: transparent;
    color: #fff;
    border: 2px solid #fff;
    padding: 12px 25px;
    margin: 10px;
    font-size: 1.1em;
    cursor: pointer;
    border-radius: 5px;
    font-family: 'PFStardust', monospace;
    text-shadow: 1px 1px 2px #000;
}

.menu button:hover, .difficulty-menu button:hover {
    background-color: rgba(255, 255, 255, 0.2);
    color: #fff;
}

#gameArea button {
    background-color: transparent;
    color: #fff;
    border: 2px solid #fff;
    padding: 12px 25px;
    margin: 10px;
    font-size: 1.1em;
    cursor: pointer;
    border-radius: 5px;
    z-index: 2;
    font-family: 'PFStardust', monospace;
    text-shadow: 1px 1px 2px #000;
}

#gameArea button:hover {
    background-color: rgba(255, 255, 255, 0.2);
    color: #fff;
}

.record {
    font-size: 0.9em;
    margin-top: 5px;
    z-index: 2;
    text-shadow: 1px 1px 2px #000;
}

.gif-image {
    width: 300px;
    height: auto;
    margin-bottom: 15px;
    z-index: 2;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

#cardGrid {
    display: grid;
    gap: 10px;
    margin: 20px 0;
    justify-content: center;
    align-content: center;
    width: max-content;
    z-index: 2;
}

.card {
    width: 100px;
    height: 100px;
    background-color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    cursor: pointer;
    border-radius: 5px;
    position: relative;
}

.box {
    width: 100%;
    height: 100%;
    background-color: #00bcd4;
    opacity: 0;
    transition: opacity 0.3s, background-color 0.3s;
    border-radius: 5px;
    cursor: pointer;
}

.box.visible {
    opacity: 1;
}

.box.correct {
    background-color: #4CAF50 !important;
    opacity: 1 !important;
    cursor: default;
}

#timer {
    font-size: 1.1em;
    margin: 10px 0;
    z-index: 2;
    text-shadow: 1px 1px 2px #000;
}

#message {
    z-index: 2;
    text-shadow: 1px 1px 2px #000;
}
    </style>
</head>
<body class="game-background">
    <h1>Î©îÎ™®Î¶¨ Í≤åÏûÑ</h1>
    <div class="menu" id="mainMenu">
        <div class="button-group">
            <img src="img/card_match.gif" alt="Card Match GIF" class="gif-image">
            <button onclick="showDifficultyMenu('matching')">Ïπ¥Îìú Îí§ÏßëÍ∏∞</button>
            <div class="record" id="record-matching">ÏµúÍ≥†Í∏∞Î°ù: ÏóÜÏùå</div>
        </div>
        <div class="button-group">
            <img src="img/process_mem.gif" alt="Process Memory GIF" class="gif-image">
            <button onclick="showDifficultyMenu('process')">ÏàúÏÑú Í∏∞Ïñµ</button>
            <div class="record" id="record-process">ÏµúÍ≥†Í∏∞Î°ù: ÏóÜÏùå</div>
        </div>
    </div>
    <div class="difficulty-menu" id="difficultyMenu" style="display: none;">
        <button onclick="startGameWithDifficulty(4)">4x4</button>
        <button onclick="startGameWithDifficulty(6)">6x6</button>
        <button onclick="startGameWithDifficulty(8)">8x8</button>
        <button onclick="backToMainMenu()">Îí§Î°ú</button>
    </div>
    <div id="gameArea" style="display: none;">
        <div id="message" style="min-height: 28px; margin: 20px 0; font-size: 1.2em;"></div>
        <div id="timer"></div>
        <div id="cardGrid"></div>
        <button onclick="resetGame()">Îã§Ïãú ÏãúÏûë</button>
    </div>
    <script>
        const cardGrid = document.getElementById('cardGrid');
        const gameArea = document.getElementById('gameArea');
        const mainMenu = document.getElementById('mainMenu');
        const difficultyMenu = document.getElementById('difficultyMenu');
        const message = document.getElementById('message');
        const timerDisplay = document.getElementById('timer');
        let cards = [];
        let flippedCards = [];
        let matchedCards = [];
        let boxSequence = [];
        let userIndex = 0;
        let currentMode = '';
        let currentSize = 4;
        let isShowingSequence = false;
        let timer;
        let timeLeft = 300;
        const emojis = ['üò∫', 'üê∂', 'üê∞', 'ü¶Å', 'üêò', 'ü¶í', 'üêº', 'ü¶ä', 'üêª', 'üêØ'];

        function updateRecords() {
            const matchingScore = localStorage.getItem('sequence_matching_score');
            const processScore = localStorage.getItem('sequence_process_score');
            const matchingRecordElement = document.getElementById('record-matching');
            const processRecordElement = document.getElementById('record-process');

            matchingRecordElement.textContent = 'ÏµúÍ≥†Í∏∞Î°ù: ÏóÜÏùå';
            processRecordElement.textContent = 'ÏµúÍ≥†Í∏∞Î°ù: ÏóÜÏùå';

            try {
                if (matchingScore) {
                    const matchingData = JSON.parse(matchingScore);
                    if (matchingData && typeof matchingData.score === 'number' && matchingData.size) {
                        matchingRecordElement.textContent = `ÏµúÍ≥†Í∏∞Î°ù: ${matchingData.score}Ï†ê (${matchingData.size}x${matchingData.size})`;
                    }
                }
            } catch (e) {
                console.error('Error parsing matching score:', e);
            }

            try {
                if (processScore) {
                    const processData = JSON.parse(processScore);
                    if (processData && typeof processData.score === 'number' && processData.size) {
                        processRecordElement.textContent = `ÏµúÍ≥†Í∏∞Î°ù: ${processData.score}Ï†ê (${processData.size}x${processData.size})`;
                    }
                }
            } catch (e) {
                console.error('Error parsing process score:', e);
            }
        }

        function getHighestClearedSize(mode) {
            const progressKey = `sequence_${mode}_progress`;
            const progress = localStorage.getItem(progressKey);
            try {
                const parsed = JSON.parse(progress);
                return parsed && parsed.highestClearedSize ? parsed.highestClearedSize : 4;
            } catch (e) {
                console.error(`Error parsing ${mode} progress:`, e);
                return 4;
            }
        }

        function saveProgress(mode, size) {
            const progressKey = `sequence_${mode}_progress`;
            const currentHighest = getHighestClearedSize(mode);
            if (size >= currentHighest) {
                localStorage.setItem(progressKey, JSON.stringify({ highestClearedSize: size }));
            }
        }

        function getNextDifficulty(currentSize) {
            const sizes = [4, 6, 8];
            const currentIndex = sizes.indexOf(currentSize);
            return currentIndex < sizes.length - 1 ? sizes[currentIndex + 1] : 8;
        }

        function showDifficultyMenu(mode) {
            currentMode = mode;
            mainMenu.style.display = 'none';
            difficultyMenu.style.display = 'flex';
        }

        function backToMainMenu() {
            difficultyMenu.style.display = 'none';
            mainMenu.style.display = 'flex';
        }

        function startGameWithDifficulty(size) {
            const highestCleared = getHighestClearedSize(currentMode);
            currentSize = size;
            if (highestCleared > size) {
                currentSize = getNextDifficulty(size);
            }
            difficultyMenu.style.display = 'none';
            gameArea.style.display = 'block';
            if (currentMode === 'matching') {
                createCards(currentSize);
                startTimer();
            } else {
                createSequenceGame(currentSize);
            }
            updateRecords();
        }

        function startTimer() {
            timeLeft = 300;
            updateTimerDisplay();
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    message.textContent = 'ÏãúÍ∞Ñ Ï¥àÍ≥º! Í≤åÏûÑ Ïò§Î≤Ñ!';
                    setTimeout(() => resetGame(), 2000);
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        function createCards(size) {
            const totalCards = size * size;
            const pairsNeeded = totalCards / 2;
            let availableEmojis = emojis;
            while (availableEmojis.length < pairsNeeded) {
                availableEmojis = availableEmojis.concat(emojis);
            }
            availableEmojis = availableEmojis.slice(0, pairsNeeded);
            const cardValues = availableEmojis.concat(availableEmojis).sort(() => Math.random() - 0.5);
            cards = Array(totalCards).fill().map((_, index) => ({
                value: cardValues[index],
                isFlipped: false,
                isMatched: false
            }));
            cardGrid.style.gridTemplateColumns = `repeat(${size}, 100px)`;
            cardGrid.style.gridTemplateRows = `repeat(${size}, 100px)`;
            cardGrid.innerHTML = '';
            cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.index = index;
                cardElement.addEventListener('click', flipCard);
                cardGrid.appendChild(cardElement);
            });
            message.textContent = `${size}x${size} Í≤åÏûÑ`;
            matchedCards = [];
            flippedCards = [];
        }

        function flipCard(event) {
            if (timeLeft <= 0) return;
            const index = parseInt(event.target.dataset.index);
            if (flippedCards.length < 2 && !cards[index].isFlipped && !cards[index].isMatched) {
                cards[index].isFlipped = true;
                event.target.textContent = cards[index].value;
                flippedCards.push(index);
                if (flippedCards.length === 2) {
                    setTimeout(checkMatch, 1000);
                }
            }
        }

        function checkMatch() {
            const [index1, index2] = flippedCards;
            const cardElements = document.querySelectorAll('.card');
            if (cards[index1].value === cards[index2].value) {
                cards[index1].isMatched = true;
                cards[index2].isMatched = true;
                cardElements[index1].style.backgroundColor = '#4CAF50';
                cardElements[index2].style.backgroundColor = '#4CAF50';
                cardElements[index1].style.cursor = 'default';
                cardElements[index2].style.cursor = 'default';
                matchedCards.push(index1, index2);
                if (matchedCards.length === cards.length) {
                    clearInterval(timer);
                    message.textContent = 'Í≤åÏûÑ ÏôÑÎ£å!';
                    saveScore('matching', cards.length / 2, currentSize);
                    saveProgress('matching', currentSize);
                    const nextSize = getNextDifficulty(currentSize);
                    setTimeout(() => startGameWithDifficulty(nextSize), 1000);
                }
            } else {
                cards[index1].isFlipped = false;
                cards[index2].isFlipped = false;
                cardElements[index1].textContent = '';
                cardElements[index2].textContent = '';
            }
            flippedCards = [];
        }

        function createSequenceGame(size) {
            const totalBoxes = size;
            cardGrid.style.gridTemplateColumns = `repeat(${size}, 100px)`;
            cardGrid.style.gridTemplateRows = `repeat(${size}, 100px)`;
            cardGrid.innerHTML = '';
            cards = Array(size * size).fill().map(() => ({}));
            for (let i = 0; i < size * size; i++) {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.index = i;
                cardGrid.appendChild(cardElement);
                cards[i].element = cardElement;
            }
            createSequence(totalBoxes);
            userIndex = 0;
            message.textContent = `${size}x${size} Í≤åÏûÑ`;
            isShowingSequence = true;
            setTimeout(() => showSequence(), 1000);
        }

        function createSequence(totalBoxes) {
            boxSequence = [];
            const usedIndices = new Set();
            while (boxSequence.length < totalBoxes) {
                const idx = Math.floor(Math.random() * cards.length);
                if (usedIndices.has(idx)) continue;
                const box = document.createElement('div');
                box.className = 'box';
                box.dataset.seq = boxSequence.length;
                cards[idx].element.appendChild(box);
                boxSequence.push(box);
                usedIndices.add(idx);
            }
        }

        function showSequence(index = 0) {
            if (index >= boxSequence.length) {
                isShowingSequence = false;
                attachBoxListeners();
                message.textContent = 'ÏàúÏÑúÎ•º Í∏∞ÏñµÌï¥ÏÑú ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî!';
                return;
            }
            const box = boxSequence[index];
            box.classList.add('visible');
            setTimeout(() => {
                box.classList.remove('visible');
                setTimeout(() => showSequence(index + 1), 500);
            }, 800);
        }

        function attachBoxListeners() {
            boxSequence.forEach(box => {
                box.addEventListener('click', handleBoxClick);
            });
        }

        function handleBoxClick(event) {
            if (isShowingSequence) return;
            const box = event.currentTarget;
            if (box.classList.contains('correct')) return;
            const clickedSeq = parseInt(box.dataset.seq, 10);

            if (clickedSeq !== userIndex) {
                message.textContent = 'ÌãÄÎ†∏ÏäµÎãàÎã§! Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî!';
                userIndex = 0;
                createSequenceGame(currentSize);
                return;
            }

            box.classList.add('correct');
            userIndex++;
            message.textContent = `Î∞ïÏä§ ${userIndex}Î≤àÏùÑ ÌÅ¥Î¶≠ÌñàÏäµÎãàÎã§!`;
            if (userIndex === boxSequence.length) {
                message.textContent = 'Î™®Îì† Î∞ïÏä§Î•º ÎßûÏ∑ÑÏäµÎãàÎã§! ÌõåÎ•≠Ìï©ÎãàÎã§!';
                saveScore('process', userIndex, currentSize);
                saveProgress('process', currentSize);
                const nextSize = getNextDifficulty(currentSize);
                setTimeout(() => startGameWithDifficulty(nextSize), 1000);
            }
        }

        function saveScore(mode, score, size) {
            const scoreKey = `sequence_${mode}_score`;
            const existingScore = localStorage.getItem(scoreKey);
            let shouldUpdate = true;
            try {
                const existing = existingScore ? JSON.parse(existingScore) : null;
                if (existing && existing.score > score) {
                    shouldUpdate = false;
                }
            } catch (e) {
                console.error(`Error parsing ${mode} score:`, e);
            }
            if (shouldUpdate) {
                const scoreObj = {
                    score: score,
                    size: size,
                    date: new Date().toISOString()
                };
                localStorage.setItem(scoreKey, JSON.stringify(scoreObj));
            }
        }

        function resetGame() {
            clearInterval(timer);
            mainMenu.style.display = 'flex';
            gameArea.style.display = 'none';
            difficultyMenu.style.display = 'none';
            matchedCards = [];
            flippedCards = [];
            boxSequence = [];
            userIndex = 0;
            isShowingSequence = false;
            cardGrid.innerHTML = '';
            currentSize = 4;
            localStorage.removeItem('sequence_matching_progress');
            localStorage.removeItem('sequence_process_progress');
            timerDisplay.textContent = '';
            updateRecords();
        }

        updateRecords();
    </script>
</body>
</html>
=======
  <meta charset="UTF-8">
  <title>Î©îÎ™®Î¶¨ Í≤åÏûÑ</title>
  <style>
    body {
      background-color: #222;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding-top: 100px;
    }

    h1 {
      font-size: 3em;
      margin-bottom: 40px;
    }

    select, button {
      font-size: 1.2em;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 8px;
    } 

    button {
      background-color: #00bcd4;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background-color: #0097a7;
    }

    .selector {
      margin-bottom: 40px;
    }
  </style>
</head>
<body>

  <h1>Î©îÎ™®Î¶¨ Í≤åÏûÑ</h1>

  <div class="selector">
    <label for="mode">Î™®Îìú ÏÑ†ÌÉù:</label>
    <select id="mode">
      <option value="flip">Ïπ¥Îìú Îí§ÏßëÍ∏∞</option>
      <option value="sequence">ÏàúÏÑú Í∏∞Ïñµ</option>
    </select>
  </div>

  <div class="selector">
    <label for="difficulty">ÎÇúÏù¥ÎèÑ:</label>
    <select id="difficulty">
      <option value="easy">Ïâ¨ÏõÄ</option>
      <option value="normal">Î≥¥ÌÜµ</option>
      <option value="hard">Ïñ¥Î†§ÏõÄ</option>
    </select>
  </div>

  <button onclick="startGame()">Í≤åÏûÑ ÏãúÏûë</button>

  <script>
    function startGame() {
      const mode = document.getElementById("mode").value;
      const difficulty = document.getElementById("difficulty").value;

      if (mode === "flip") {
        window.location.href = `flip-game.html?difficulty=${difficulty}`;
      } else if (mode === "sequence") {
        window.location.href = `sequence-game.html?difficulty=${difficulty}`;
      }
    }
  </script>

</body>
</html>
>>>>>>> f045e6571c0123caea01785eea46c90c54973751
